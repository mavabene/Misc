# -*- coding: utf-8 -*-
"""CS10_tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xSscAqHoR9cpC9qIfb6fys4xL9WDZEXv
"""

# Lab 12 (Python Lab 1) Intro to Python

# mod: x%y
# less than (predicate): x < y
# less than or equal to (predicate): x <= y
# equals (predicate): x == y
# not equal (predicate): x != y
# not (predicate): not x
# power: **
# floor division: //
# add to: +=  (eg x=x+2: x+=2), similarly -=, *=, /+, %=, //=, **=, &=, |=, ^=, >>=, <<=

# fprint, input
food=input("favorite food")
drink=input("favorite drink")
print(f"I like {food}'s and {drink}'s!")

# FOR LOOP, Function
def count_up(num):
  for i in range(1, num+1):
    print(i)

count_up(4)
print(' ')

# WHILE LOOPS (aka "repeat until" in snap)
def count_up_while(num):
  i = 1
  while i <= num:
    print(i)
    i +=1
  
count_up_while(4)
print(' ')

# RETURN
def times_5(x):
  return 5*x

print(times_5(3))
print(' ')

# RANGE

def sum_all_numbers(x,y):
  total=0
  for i in range(x,y+1):
    total=total+i
  return total

print(sum_all_numbers(5,9))
print(' ')

# CONDITIONALS: IF, ELSE IF, ELSE; RECURSION

def fib(n):
  if n==0:
    return 0
  elif n==1:
    return 1
  else:
    return fib(n-1)+fib(n-2)

fb=10
print('fibonacci of',fb,': ',fib (fb))
print(' ')

# TURTLE

# import turtle as trt
# trt.forward(100)
# trt.backward(100)
# trt.right(45)
# trt.penup()" and ".join(["h", "e", "l", "l", "o"])
# trt.pendown()
# trt.goto(130-50)
# trt.clear()

# Lab 13 (Python Lab2) Data Structures

# basic list - can contain any type or mix of data
# mutable
names = ["John", "Paul", "George", "Pete"]
print('list of names: ',names)

# access with brackets - lists start at 0
print('item 0 of "names": ',names[0])

# retrieve length of list
print('length of "names" is: ',len(names))

# join lists
foodnames = ["Taco", "Ramen"] + ["Pizza", "Aloo Gobi"]

print('foodnames: ',foodnames)

# access list with indices
print ('items 1:3 of foodnames: ',foodnames[1:3]) # doesn't include end index
print ('items 2: of foodnames: ',foodnames[2:])
print ('items :2 of foodnames: ',foodnames[:2]) # again, doesn't include end index

# can use index to change item
foodnames[2]="Spaghetti"
print('replaced item 2 of foodnames: ',foodnames)

# = will create another label that points to the same thing
dinner=foodnames
print("dinner: ",dinner)
dinner[2]='Puttanesca'
print("Added item to dinner, but added to original list as well - foodnames: ",foodnames) # foodnames is also changed!

# TUPLES??
thistuple = ("apple",)
print(type(thistuple))

#NOT a tuple
thistuple = ("apple") # a string, because no comma
print(type(thistuple))

# STRINGS - inmutable
a = "potato"
b = a
a += a
print("print a (potato) + a = : ",a)
print("b=a, then change a, then print b: still potato(unchanged)?: ",b)

# to make a completely separate copy of a LIST, use [:] operator
lunch = dinner[:]
print('dinner: ', dinner)
print('lunch: ', lunch)
lunch [2]= "burrito" # doesn't change original list because it's 
# another separate list, not just a label pointing to the same list
print('modified lunch as a copy of dinner, so dinner remains: ', dinner)
print('but lunch is modified: ', lunch)

# append(item) - mutates list by adding item to end
lunch.append("veggie burger")

" and ".join(["h", "e", "l", "l", "o"])
print('appended lunch: ', lunch)

# insert(index, item)
lunch.insert(3, "pizza")
print("pizza inserted at index 3 of lunch: ", lunch)

# pop(index) (if no index given - pop() - last item of list will be removed)
lunch.pop(1)
print('index 1 item removed from lunch with pop: ', lunch)

# ITERABLES
for i in range (0,5):
  print(i)

for item in lunch:
  print("Let's eat a " + item)

sos="SOS"
for letter in sos:
    print(letter)

# NESTED LISTS - 2d

produce=["kale", "spinach","sprouts"]
fruit=["papaya","mango","banana"]
cart=[produce,fruit]
print(cart)

print(cart[0]) # retrieve first list
print(cart[0][2]) # retrieve item from 2d list

cart[0][2]='lettuce'
print("modified cart: ",cart)
print("produce is also changed: ",produce)

# LIST COMPREHENSIONS - [function (x) for x in list]

# MAP - produces new list without changing original

list_a=[1,2,3]
list_mapped_a=[x*x for x in list_a]
print('original list: ', list_a)
print('mapped list: ', list_mapped_a)
 
# KEEP - [x for x in list if predicate(x)]

list_c=[x for x in list_a if x<3]
print(list_c)

# JOIN - .join function of a list
hello="".join(["h", "e", "l", "l", "o"])
print('join h,e,l,l,o with .join: ',hello)

andhello=" and ".join(["h", "e", "l", "l", "o"])
print('with and inserted .join: ',andhello)

# List comprehension and strings - returning a string
def less_than_m(text):
   return [letter for letter in text if letter <"m"]

print('joined list comprehension result example (<m): ', "".join(less_than_m("ijklmnop")))

# Combine - not a good combine function in python. Better to write a loop yourself.
# "all but first of" in python is approximately [1:]

# DICTIONARIES - like a list, but not sorted by index, items attached to a keyword: (key,value) pairs.  
# Keys must be unique, values can duplicate.
# dict.get("value"), dict.pop("value"), dic.keys(), dict.values()

grades = {}
grades ["Bob"]=85
grades["Alice"]=90
grades["James"]=100
print('printing the "grades" dictionary: ',grades)
print('obtain a given entry: ', grades.get("Alice")) # or can use grades["Alice"]
print('get dictionary values: ', grades.values()) 

strings_dict={"guitar":"pluck","violin":"bow","bass":"pluck"}
strings_dict["viola"]="either"
print('alt method defining dict: ',strings_dict)
# dict.keys() and dict.values() don't return lists in python 3.  To convert to list:
# CONVERT TO LIST - list()

gradeslist=list(grades.values())
print("dict values converted to list", gradeslist)

# check if key exists - "Value" in dictionary
print('"Value" in dictionary: ', "Alice" in grades)

# modify value in dictionary:
grades["Alice"] +=5
print('grades["Alice"] +=5')
print('show modified value: ',grades)

# continued!

# Classes

class Time():
  def time_in_seconds_t(t):  # method - a function that is part of a class.
    # functions that can automatically have their first argument filled in
    # by an instance are called "instance methods".
    return t.hour * 3600 + \
           t.minute * 60 + \
           t.second

  def time_in_seconds(self):  # method - a function that is part of a class.
             # convention is to use self, instead of 't'
    return self.hour * 3600 + self.minute * 60 + self.second

  def __init__(self,h,m,s):  # defines what the attributes are
    self.hour=h
    self.minute=m
    self.second=s

  def __str__(self): # informal or nicely printable representation
    return f"{self.hour}:{self.minute}:{self.second}" # defines string representation

  def __lt__(self, other):
    if self.hour < other.hour:
      return True
    if self.hour == other.hour:
      if self.minute < other.minute:
        return True
      if self.minute== other.minute:
        return self.second<other.second
    return False

  def __repr__(self):  # "representation" - official representation
                       # str not delivered unless called to print. eg repr 
                       # used to deliver when calling a list of Time's
    return str(self)
      
# INHERITANCE 
class Late_Time(Time): # inherits Time class (Time subclass), adds late attribute.
  def late(self):
      print(f"{self.hour} hours is late!")


#  allows going to continue with next line, just
# a visual break - but can't put comment after!
# or even a space

# t1 = Time()  This no longer works after creating __init__

# t1.hour = 17
# t1.minute = 12
# t1.second = 39
t1=Time(17,12,39)

# using __init__ to create Time instance:
t2=Time(17,10,22) # after defining __str__ method will return 17:10:22
                  # vs just a memory location

print(f'First way to call time in seconds: {Time.time_in_seconds(t1)}.')
print(f'Second way to call time in seconds: {t1.time_in_seconds()}.')

print(t2)
print(str(t2)) # other way to get str
print(f'Second way to call time in seconds: {t2.time_in_seconds()}.')

t3=Time(17,10,23) # can not put 0 in front - eg 07,08,09
t4=Time(11,11,59)
t5=Time(17,18,19)

print(f'compare {t3} < {t2}: {(t3<t2)} ')
print(f'compare {t2} < {t3}: {(t2<t3)} ')
print(f'compare {t3} > {t2}: {(t3>t2)} ') # also works, even though did not 
                                          # create __gt__ !!!

LTime=[t2, t3, t4]
Lsorted=sorted(LTime)
print(f'printing sorted Times (per repr method) ({t2},{t3},{t4}): {Lsorted}')

# also, if repr didn't exist, could print list by:
print(f"printing list with string comprehension if repr doesn't exist: {[str(x) for x in Lsorted]}")

t6=Late_Time(23,33,45) # inherits Time class
print(f"{t6.late()}")

# Object Oriented Programming

# Object: An object is a collection of data with its own methods, attributes, and identity.
# Method: A function that an object has. For example, the Python Turtle object has the method forward that causes the sprite to move forward.
# Attribute: Basically, a variable that belongs to an object. For example, a Turtle object's coordinates are its attributes.
# Class: A class is the blueprint of an object; it is the precise definition of an object's methods and attributes.
# Constructor: The constructor is the method that Python uses when it creates (instantiates) an object. Not all attributes of a class are defined immediately, the constructor lets you define an object's attributes when you actually create the object.
# Instance: An instance is an object made from a specific class. For example, your friend's iPhone is basically an instance of the iPhone class.
# Instantiation: The creation of an instance. This is when the constructor actually creates the object.

# Text Processing

def read_file(filename):  
  """Returns the text contained in file with given filename."""
  f = open(filename, "r").  # accesses file (from current directory) and gives it a place in memory
  text = f.read().          # reads the file to a printable form (text)
  return(text)

  def pig_latin(word):
  """Returns the pig latin translation of a word. """
  vowel_list="aeiou"  # creating a string to access desired characters
  i=0
  while word[i] not in vowel_list:  # keeps moving first letter to end of string until hitting a vowel
    """move letter to end of word"""
    word=word[1:]+word[0]  
  return word + "ay".  # joining text

def izzle(word):
  """ Returns the izzle translation of a word. """
  if not word[0].isalpha():  # how to access alphabet.  Can also do upper and lower case.
    return word 
  vowels="aeiou"
  i=1
  while word[-i] not in vowels:  # last letter of word
    i+=1
    if len(word)==i:  # had to add this, because otherwise a word like "by" would be seen as only consonants and index out
      return word
  word=word[0:-i]+"izzle" # Keeps word up to the vowel
  return word

def apply_language_game(text, language_game):   #  get string out of index error for gettysburg
  """Takes a text and a language_game function as inputs"""
  """ Returns the language game function applied to every word of the text. """
  return " ".join([language_game(x) for x in text.split()])

def text_to_list(text):
  return text.split(). # text.split(separator,maxsplit) splits string of words according to separator - space by default (could be comma, capital letter, etc), maxsplit splits up this number of times (default no limit)

def top_n_words(counts, n):  # counts is dictionary with words as keys and values as # occurences
    """Returns the top n words by count. For example:

    top_n_words({'and': 5, 'on': 1, 'Vegetables': 5, 'Budget': 1, 'to': 1, 'Fruit': 1, 'a': 2, 'Clean': 1, 'Fruits': 1, 'Store': 1, 'at': 1}, 2)

    would return ["and", "Vegetables"].

    In the case of a tie, it doesn't matter which words are chosen to break the tie."""

    x = sorted(counts, key=counts.get, reverse=True). # sorts dict or list, various kinds of keys exist, this .get sorts according to values in counts dictionary
    return x[:n]

# DEBUGGING

# python -m doctest -v oop_debugging.py  # runs debugging text in ''' here '''